<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>금연사업 지침 문의 Chatbot4</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'brand-bg': '#131314',
              'brand-surface': '#1e1f20',
              'brand-primary': '#8ab4f8',
              'brand-secondary': '#4e5052',
              'brand-text-primary': '#e8eaed',
              'brand-text-secondary': '#bdc1c6',
            }
          }
        }
      }
    </script>
    <script type="importmap">
    {
      "imports": {
        "@google/genai": "https://aistudiocdn.com/@google/genai@^1.16.0"
      }
    }
    </script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
      // Set worker source for pdf.js from CDN
      pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
    </script>
  <link rel="stylesheet" href="/index.css">
</head>
  <body class="bg-brand-bg text-brand-text-primary">
    <div id="root"></div>
    <script>
      // 환경변수에서 API 키를 가져옵니다
      // API 키 설정
      const GEMINI_API_KEY = 'YOUR_GEMINI_API_KEY_HERE';
    </script>
    <script type="text/babel" data-type="module">
      import { GoogleGenAI } from "@google/genai";

      const { useState, useCallback, useMemo, useRef, useEffect, StrictMode } = React;

      // --- Inlined from types.ts ---
      const Role = {
        USER: 'user',
        MODEL: 'model',
      };
      
      // --- Inlined from services/geminiService.ts ---
      if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_GEMINI_API_KEY_HERE') {
          throw new Error("API_KEY is not set. Please configure your Gemini API key.");
      }
      const ai = new GoogleGenAI({ apiKey: GEMINI_API_KEY });
      const SYSTEM_INSTRUCTION_TEMPLATE = `You are an expert assistant. Your name is NotebookLM Assistant. 
      You must answer questions based ONLY on the following source material provided. 
      Do not use any external knowledge or your pre-trained knowledge. 
      If the answer cannot be found in the source material, you must state that the information is not available in the provided context. 
      Be concise, helpful, and cite which part of the source you are referring to if possible.

      Here is the source material:
      ---START OF SOURCE---
      {sourceText}
      ---END OF SOURCE---`;

      function createNotebookChatSession(sourceText) {
          const systemInstruction = SYSTEM_INSTRUCTION_TEMPLATE.replace('{sourceText}', sourceText);

          const chat = ai.chats.create({
              model: 'gemini-2.5-flash',
              config: {
                  systemInstruction: systemInstruction,
              },
              history: [],
          });
          return chat;
      }

      // --- Inlined from components/icons/UserIcon.tsx ---
      const UserIcon = ({ className = "w-6 h-6" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 24 24" fill="currentColor">
              <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z" />
          </svg>
      );

      // --- Inlined from components/icons/BotIcon.tsx ---
      const BotIcon = ({ className = "w-6 h-6" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 24 24" fill="currentColor">
              <path d="M19.98 10.98c0-4.96-4.02-8.98-8.98-8.98S2 6.02 2 10.98v3.03c0 .54.44.99.99.99h1.01V12h-2c0-4.41 3.59-8 8-8s8 3.59 8 8v2.01h-2v-2.01c0-.54-.44-.99-.99-.99H18v2.01h2v-2.04zM12 15c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm1.5-1.5c0-.83-.67-1.5-1.5-1.5S12 10.67 12 11.5s.67 1.5 1.5 1.5.5-.67.5-1.5z" opacity=".3" />
              <path d="M21 12v-1.02c0-4.96-4.02-8.98-8.98-8.98S3.04 6.02 3.04 10.98V12H2v2.01h1.05v2.99c0 .54.44.99.99.99H6v-2.01H4.04v-2.99H20v2.99h-2.01V20h2.01c.54 0 .99-.44.99-.99v-2.99H22V12h-1zm-9 3c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm1.5-1.5c0-.83-.67-1.5-1.5-1.5S10.5 10.67 10.5 11.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5z" />
          </svg>
      );

      // --- Inlined from components/icons/SendIcon.tsx ---
      const SendIcon = ({ className = "w-6 h-6" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 24 24" fill="currentColor">
              <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" />
          </svg>
      );
      
      // --- Inlined from components/icons/DocumentIcon.tsx ---
      const DocumentIcon = ({ className = "w-6 h-6" }) => (
        <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m-1.5 0-3.75 3.75m3.75-3.75V4.5m0 13.5h-3a1.5 1.5 0 0 1-1.5-1.5v-10.5a1.5 1.5 0 0 1 1.5-1.5h3.75a1.5 1.5 0 0 1 1.5 1.5v10.5a1.5 1.5 0 0 1-1.5 1.5h-3.75Z" />
        </svg>
      );

      // --- New Component: SourceInfo ---
      const SourceInfo = ({ isLoading, files }) => (
          <div className="flex flex-col h-full bg-brand-surface rounded-lg p-4">
              <h2 className="text-lg font-semibold text-brand-primary mb-3">자료 출처</h2>
              {isLoading ? (
                  <div className="flex flex-col items-center justify-center flex-1">
                      <div className="w-8 h-8 border-4 border-brand-primary border-t-transparent rounded-full animate-spin mb-4"></div>
                      <p className="text-brand-text-primary">문서 목록 확인 및 로딩 중...</p>
                      <p className="text-sm text-brand-text-secondary">자료를 준비하고 있습니다.</p>
                  </div>
              ) : (
                  <div>
                      <p className="text-sm text-brand-text-secondary mb-4">
                          챗봇은 아래 문서들을 기반으로 답변합니다.
                      </p>
                      <ul className="space-y-2">
                          {files.map((file, index) => (
                              <li key={index} className="flex items-center gap-2 text-brand-text-secondary text-sm">
                                  <DocumentIcon className="w-5 h-5 flex-shrink-0" />
                                  <span>{file}</span>
                              </li>
                          ))}
                      </ul>
                  </div>
              )}
          </div>
      );
      
      // --- Inlined from components/Message.tsx ---
      const Message = ({ message }) => {
          const isUser = message.role === Role.USER;

          return (
              <div className={`flex items-start gap-4 p-4 ${isUser ? '' : 'bg-brand-surface/50 rounded-lg'}`}>
                  <div className={`flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center ${isUser ? 'bg-brand-secondary' : 'bg-brand-primary'}`}>
                      {isUser ? <UserIcon className="w-5 h-5 text-brand-text-primary" /> : <BotIcon className="w-5 h-5 text-brand-bg" />}
                  </div>
                  <div className="flex-1 pt-1">
                      <p className="font-semibold text-brand-text-primary mb-1">{isUser ? 'You' : 'Assistant'}</p>
                      <p className="text-brand-text-secondary whitespace-pre-wrap">{message.content}</p>
                  </div>
              </div>
          );
      };
      
      // --- Inlined from components/MessageInput.tsx ---
      const MessageInput = ({ currentMessage, setCurrentMessage, onSendMessage, isLoading, disabled }) => {
          const isInputDisabled = isLoading || disabled;

          return (
              <form onSubmit={onSendMessage} className="p-4 bg-brand-surface">
                  <div className="relative">
                      <input
                          type="text"
                          value={currentMessage}
                          onChange={(e) => setCurrentMessage(e.target.value)}
                          placeholder={disabled ? "자료를 로딩 중입니다..." : "질문을 입력하세요..."}
                          disabled={isInputDisabled}
                          className="w-full bg-brand-bg border border-brand-secondary rounded-full py-3 pl-4 pr-12 text-brand-text-primary focus:outline-none focus:ring-2 focus:ring-brand-primary disabled:opacity-50"
                      />
                      <button
                          type="submit"
                          disabled={isInputDisabled || !currentMessage}
                          className="absolute right-2 top-1/2 -translate-y-1/2 p-2 rounded-full text-brand-primary hover:bg-brand-primary/20 disabled:text-brand-secondary disabled:hover:bg-transparent transition-colors"
                      >
                          <SendIcon className="w-6 h-6" />
                      </button>
                  </div>
              </form>
          );
      };

      // --- Inlined from components/ChatWindow.tsx ---
      const ChatWindow = ({ messages, isLoading, sourceProvided, isParsingDocs }) => {
          const scrollRef = useRef(null);

          useEffect(() => {
              if (scrollRef.current) {
                  scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
              }
          }, [messages, isLoading]);

          return (
              <div ref={scrollRef} className="flex-1 overflow-y-auto p-4 space-y-4">
                   {messages.length === 0 && isParsingDocs && (
                        <div className="text-center text-brand-text-secondary p-8 flex flex-col items-center justify-center h-full">
                            <div className="w-8 h-8 border-4 border-brand-primary border-t-transparent rounded-full animate-spin mb-4"></div>
                            <h3 className="text-xl font-semibold text-brand-text-primary">자료 로딩 중</h3>
                            <p>챗봇을 시작하기 위해 문서를 준비하고 있습니다.</p>
                        </div>
                   )}
                   {messages.length === 0 && !isParsingDocs && !sourceProvided && (
                        <div className="text-center text-brand-text-secondary p-8 flex flex-col items-center justify-center h-full">
                            <DocumentIcon className="w-12 h-12 mb-4 text-brand-secondary" />
                            <h3 className="text-xl font-semibold text-brand-text-primary">오류 발생</h3>
                            <p>문서 로딩에 실패했습니다. 페이지를 새로고침 해주세요.</p>
                        </div>
                   )}
                   {messages.length === 0 && !isParsingDocs && sourceProvided && (
                      <div className="text-center text-brand-text-secondary p-8 flex flex-col items-center">
                          <BotIcon className="w-12 h-12 mb-4 text-brand-primary" />
                          <h3 className="text-xl font-semibold text-brand-text-primary">채팅 준비 완료</h3>
                          <p>문서가 로드되었습니다. 질문을 시작하세요.</p>
                      </div>
                  )}
                  {messages.map((msg, index) => (
                      <Message key={index} message={msg} />
                  ))}
                  {isLoading && messages.length > 0 && messages[messages.length - 1].role === 'user' && (
                       <div className="flex items-start gap-4 p-4 bg-brand-surface/50 rounded-lg">
                          <div className="flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center bg-brand-primary">
                              <BotIcon className="w-5 h-5 text-brand-bg" />
                          </div>
                          <div className="flex-1 pt-1">
                              <p className="font-semibold text-brand-text-primary mb-1">Assistant</p>
                              <div className="flex items-center gap-2">
                                  <span className="w-2 h-2 bg-brand-text-secondary rounded-full animate-pulse [animation-delay:-0.3s]"></span>
                                  <span className="w-2 h-2 bg-brand-text-secondary rounded-full animate-pulse [animation-delay:-0.15s]"></span>
                                  <span className="w-2 h-2 bg-brand-text-secondary rounded-full animate-pulse"></span>
                              </div>
                          </div>
                      </div>
                  )}
              </div>
          );
      };

      // --- Inlined from App.tsx ---
      const App = () => {
          const [sourceText, setSourceText] = useState('');
          const [messages, setMessages] = useState([]);
          const [currentMessage, setCurrentMessage] = useState('');
          const [isLoading, setIsLoading] = useState(false);
          const [isParsing, setIsParsing] = useState(true);
          const [discoveredFiles, setDiscoveredFiles] = useState([]);
          const [error, setError] = useState(null);

          const PDF_BASE_URL = 'https://ggawoos-bot.github.io/chat/pdf/';

          const chatSession = useMemo(() => {
              if (sourceText.trim()) {
                  try {
                    return createNotebookChatSession(sourceText);
                  } catch (e) {
                    console.error("Error creating chat session:", e);
                    setError(e instanceof Error ? e.message : "Failed to create chat session.");
                    return null;
                  }
              }
              return null;
          }, [sourceText]);
          
          const parsePdfFromUrl = async (url) => {
              try {
                  const pdfData = await fetch(url).then(res => {
                      if (!res.ok) {
                          throw new Error(`Failed to fetch ${url}: ${res.statusText}`);
                      }
                      return res.arrayBuffer();
                  });
                  const pdf = await pdfjsLib.getDocument({ data: new Uint8Array(pdfData) }).promise;
                  let fullText = '';
                  for (let i = 1; i <= pdf.numPages; i++) {
                      const page = await pdf.getPage(i);
                      const textContent = await page.getTextContent();
                      const pageText = textContent.items.map(item => item.str).join(' ');
                      fullText += pageText + '\n\n';
                  }
                  return fullText;
              } catch (err) {
                  console.error(`Error parsing PDF from ${url}:`, err);
                  throw new Error(`Failed to parse ${url.split('/').pop()}: ${err.message}`);
              }
          };

          useEffect(() => {
            const discoverAndParsePdfs = async () => {
                setIsParsing(true);
                setError(null);
                setSourceText('');
                setMessages([]);
                setDiscoveredFiles([]);

                try {
                    // Step 1: Fetch the manifest file to discover PDF files
                    const manifestUrl = `${PDF_BASE_URL}manifest.json`;
                    const manifestResponse = await fetch(manifestUrl);
                    if (!manifestResponse.ok) {
                        throw new Error(`Could not load file list (manifest.json). Status: ${manifestResponse.statusText}`);
                    }
                    const pdfFiles = await manifestResponse.json();

                    if (!Array.isArray(pdfFiles) || pdfFiles.length === 0) {
                        throw new Error("No PDF files found in manifest.json or the file is invalid.");
                    }
                    setDiscoveredFiles(pdfFiles);

                    // Step 2: Parse the discovered PDF files
                    const parsingPromises = pdfFiles.map(file => parsePdfFromUrl(PDF_BASE_URL + file));
                    const texts = await Promise.all(parsingPromises);
                    const combinedText = texts.join('\n--- END OF DOCUMENT ---\n\n--- START OF DOCUMENT ---\n');
                    setSourceText(combinedText);
                } catch (err) {
                    console.error("Error loading PDFs:", err);
                    setError(err instanceof Error ? err.message : 'An unknown error occurred during loading.');
                    setDiscoveredFiles([]); // Clear file list on error
                } finally {
                    setIsParsing(false);
                }
            };
            
            discoverAndParsePdfs();
        }, []); // Empty dependency array ensures this runs only once on mount

          const handleSendMessage = useCallback(async (e) => {
              e.preventDefault();
              if (!currentMessage.trim() || !chatSession || isLoading) return;

              const userMessage = { role: Role.USER, content: currentMessage.trim() };
              setMessages(prev => [...prev, userMessage]);
              setCurrentMessage('');
              setIsLoading(true);
              setError(null);

              try {
                  const stream = await chatSession.sendMessageStream({ message: userMessage.content });

                  let modelResponse = '';
                  setMessages(prev => [...prev, { role: Role.MODEL, content: '' }]);

                  for await (const chunk of stream) {
                      modelResponse += chunk.text;
                      setMessages(prev => {
                          const newMessages = [...prev];
                          newMessages[newMessages.length - 1].content = modelResponse;
                          return newMessages;
                      });
                  }
              } catch (err) {
                  console.error(err);
                  const errorMessage = err instanceof Error ? err.message : 'An unknown error occurred.';
                  setError(`Failed to get response: ${errorMessage}`);
                  setMessages(prev => {
                      const newMessages = [...prev];
                      if(newMessages[newMessages.length - 1].role === Role.MODEL) {
                        newMessages.pop();
                      }
                      return [...newMessages, { role: Role.MODEL, content: `Sorry, I encountered an error. ${errorMessage}` }];
                  });

              } finally {
                  setIsLoading(false);
              }
          }, [chatSession, currentMessage, isLoading]);

          return (
              <div className="h-screen w-screen flex flex-col p-4 gap-4 bg-brand-bg">
                  <header className="text-center">
                      <h1 className="text-2xl font-bold text-brand-text-primary">금연사업 지침 문의 Chatbot</h1>
                  </header>
                  
                  <main className="flex-1 grid grid-cols-1 md:grid-cols-2 gap-4 min-h-0">
                      {/* Source Info Column */}
                      <div className="flex flex-col min-h-0">
                           <SourceInfo
                                isLoading={isParsing}
                                files={discoveredFiles}
                           />
                      </div>
                      
                      {/* Chat Column */}
                      <div className="flex flex-col h-full bg-brand-surface rounded-lg min-h-0">
                          <div className="flex-1 flex flex-col min-h-0">
                            <h2 className="text-lg font-semibold text-brand-primary p-4 border-b border-brand-secondary">질문하기</h2>
                              <>
                                 {error && <div className="p-4 bg-red-900/50 text-red-300 border-b border-red-700">{error}</div>}
                                 <ChatWindow 
                                     messages={messages} 
                                     isLoading={isLoading} 
                                     sourceProvided={!!chatSession}
                                     isParsingDocs={isParsing}
                                 />
                                 <MessageInput
                                      currentMessage={currentMessage}
                                      setCurrentMessage={setCurrentMessage}
                                      onSendMessage={handleSendMessage}
                                      isLoading={isLoading}
                                      disabled={!chatSession || isParsing}
                                  />
                              </>
                          </div>
                      </div>
                  </main>
              </div>
          );
      };

      // --- Inlined from index.tsx ---
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }

      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <StrictMode>
          <App />
        </StrictMode>
      );
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>
